name: Test dotnet-test action
description: Test to validate that the dotnet-test action builds, tests, and applies semantic versioning correctly

runs:
  using: composite
  steps:
    - name: Setup test environment
      shell: bash
      run: |
        # Save initial state
        git rev-parse HEAD > /tmp/original_head

        # Save the list of tags and their commits
        git tag --list | while read tag; do
            echo "$tag $(git rev-list -n 1 "$tag")"
        done > /tmp/original_tags

        # Ensure origin/HEAD symbolic ref is set up for semantic version detection
        # Why this is needed:
        # 1. After git operations (resets, cleanups) from previous tests, this ref may be broken
        # 2. After repository corruption/recreation from permission issues, it may not exist
        # 3. The semantic version assertion uses git symbolic-ref to determine the default branch
        # 4. Without this, the assertion would fail with "not a symbolic ref" on main branch
        if ! git symbolic-ref refs/remotes/origin/HEAD >/dev/null 2>&1; then
            git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/${{ github.event.repository.default_branch }}
        fi

    - id: version
      name: Get semantic version
      uses: spritely/actions.semantic-version/get@v0.5.6
      with:
        skipCheckout: true
        writeSummary: false

    - name: Run dotnet-test action
      uses: ./dotnet-test
      with:
        nugetAuthToken: fake-token
        projectFile: TestProject.csproj
        projectDirectory: ./tests/sample-projects/half-covered/TestProject
        unitTestProjects: ./tests/sample-projects/half-covered/**/*.UnitTests.csproj
        coverageThreshold: 50
        registryHost: localhost:5000
        registryUsername: testuser
        registryPassword: testpassword
        writeSummary: false

    - name: Initialize test
      shell: bash
      run: |
        source ${{ github.workspace }}/tests/test-reporter.sh
        initialize_test "dotnet-test action builds, tests, and applies semantic versioning" "dotnet-test-test"

    - name: Assert tests ran successfully
      shell: bash
      run: |
        source ${{ github.workspace }}/tests/test-reporter.sh
        set_test_name "Assert tests ran successfully"

        # Check if test output contains expected success indicators
        # This test passes if the action completed without errors
        # The actual test execution and coverage validation is handled by the action itself
        success "dotnet-test action completed successfully"

    - name: Assert coverage threshold was met
      shell: bash
      run: |
        source ${{ github.workspace }}/tests/test-reporter.sh
        set_test_name "Assert coverage threshold was met"

        # Since we set coverageThreshold to 50% and the half-covered project should meet this,
        # if the action completed successfully, the coverage requirement was met
        success "Coverage threshold of 50% was met by half-covered test project"

    - name: Assert semantic version was applied (on default branch)
      shell: bash
      run: |
        source ${{ github.workspace }}/tests/test-reporter.sh
        set_test_name "Assert semantic version was applied"

        # Check if we're on the default branch
        # Using git symbolic-ref to match how semantic-version/apply determines the default branch
        # This ensures the test expectation aligns with actual semantic versioning behavior
        current_branch=$(git branch --show-current)
        default_branch=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')

        if [ "$current_branch" = "$default_branch" ]; then
            # On default branch, check if version tag was created
            if git tag --list | grep -q "^v${{ steps.version.outputs.version }}$"; then
                success "Semantic version tag v${{ steps.version.outputs.version }} was applied"
            else
                failure "Semantic version tag v${{ steps.version.outputs.version }} was not created"
            fi
        else
            # Not on default branch, semantic version should not be applied
            if git tag --list | grep -q "^v${{ steps.version.outputs.version }}$"; then
                failure "Semantic version tag should not be applied on non-default branch"
            else
                success "Semantic version tag correctly not applied on non-default branch"
            fi
        fi

    - name: Test clean up
      shell: bash
      if: always()
      run: |
        # Clean up coverage results and build outputs to prevent git checkout failures in next test
        sudo rm -rf ${{ github.workspace }}/covered-test-results || true
        find ${{ github.workspace }}/tests/sample-projects -type d \( -name "bin" -o -name "obj" \) -exec sudo rm -rf {} + 2>/dev/null || true

    - name: Test coverage threshold enforcement (negative test)
      id: high-threshold-test
      uses: ./dotnet-test
      continue-on-error: true
      with:
        nugetAuthToken: fake-token
        projectFile: TestProject.csproj
        projectDirectory: ./tests/sample-projects/half-covered/TestProject
        unitTestProjects: ./tests/sample-projects/half-covered/**/*.UnitTests.csproj
        coverageThreshold: 70
        registryHost: localhost:5000
        registryUsername: testuser
        registryPassword: testpassword
        writeSummary: false

    - name: Assert coverage threshold enforcement worked
      shell: bash
      run: |
        source ${{ github.workspace }}/tests/test-reporter.sh
        set_test_name "Assert coverage threshold enforcement with 70% threshold"

        # Check if the previous step failed as expected
        if [ "${{ steps.high-threshold-test.outcome }}" = "failure" ]; then
            success "dotnet-test action correctly failed with 70% coverage threshold (half-covered project has 50% coverage)"
        else
            failure "dotnet-test action should have failed with 70% coverage threshold, but outcome was: ${{ steps.high-threshold-test.outcome }}"
        fi

    - name: Clean up test environment
      shell: bash
      if: always()
      run: |
        # Clean up coverage results and build outputs
        sudo rm -rf ${{ github.workspace }}/covered-test-results || true
        find ${{ github.workspace }}/tests/sample-projects -type d \( -name "bin" -o -name "obj" \) -exec sudo rm -rf {} + 2>/dev/null || true

        # Reset repository to original state
        git reset --hard $(cat /tmp/original_head)

        # Delete any tags not in the original list
        git tag | while read tag; do
            if ! grep -q "^$tag " /tmp/original_tags; then
                echo "Deleting extra tag: $tag"
                git tag -d "$tag" 2>/dev/null || true
            fi
        done

    - name: Finalize test
      shell: bash
      if: always()
      run: |
        source ${{ github.workspace }}/tests/test-reporter.sh
        finalize_test
